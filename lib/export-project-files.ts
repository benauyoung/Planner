import type { Project, PlanNode } from '@/types/project'

/**
 * Generate .cursorrules content from a VisionPath project.
 */
export function generateCursorRules(project: Project): string {
  const sections: string[] = []

  sections.push(`# Project: ${project.title}`)
  if (project.description) {
    sections.push(`\n${project.description}`)
  }

  // Architecture overview from goals
  const goals = project.nodes.filter((n) => n.type === 'goal')
  if (goals.length > 0) {
    sections.push('\n## Project Goals')
    for (const goal of goals) {
      sections.push(`- ${goal.title}${goal.description ? `: ${goal.description}` : ''}`)
    }
  }

  // Key decisions from Q&A
  const decisions = collectAllDecisions(project.nodes)
  if (decisions.length > 0) {
    sections.push('\n## Key Decisions')
    for (const d of decisions) {
      sections.push(`- ${d.context}: ${d.question} → ${d.answer}`)
    }
  }

  // Current focus — in-progress features
  const inProgress = project.nodes.filter((n) => n.status === 'in_progress')
  if (inProgress.length > 0) {
    sections.push('\n## Current Focus')
    for (const node of inProgress) {
      sections.push(`- [${node.type}] ${node.title}`)
    }
  }

  // Constraints from PRDs
  const constraints = collectConstraints(project)
  if (constraints.length > 0) {
    sections.push('\n## Constraints')
    for (const c of constraints) {
      sections.push(`- ${c}`)
    }
  }

  sections.push('\n## Rules')
  sections.push('- Follow the project plan structure when implementing features')
  sections.push('- Check task acceptance criteria before marking complete')
  sections.push('- Ask before making architectural changes that affect multiple goals')

  return sections.join('\n')
}

/**
 * Generate CLAUDE.md content from a VisionPath project.
 */
export function generateClaudeMD(project: Project): string {
  const sections: string[] = []

  sections.push(`# ${project.title}`)
  if (project.description) {
    sections.push(`\n${project.description}`)
  }

  sections.push('\n## Project Structure')
  const goals = project.nodes.filter((n) => n.type === 'goal')
  for (const goal of goals) {
    sections.push(`\n### ${goal.title}`)
    if (goal.description) sections.push(goal.description)

    const subgoals = project.nodes.filter((n) => n.parentId === goal.id)
    for (const sg of subgoals) {
      sections.push(`\n#### ${sg.title}`)
      if (sg.description) sections.push(sg.description)

      const features = project.nodes.filter((n) => n.parentId === sg.id)
      for (const f of features) {
        sections.push(`- **${f.title}** \`[${f.status}]\` — ${f.description || 'No description'}`)
      }
    }
  }

  // Decisions
  const decisions = collectAllDecisions(project.nodes)
  if (decisions.length > 0) {
    sections.push('\n## Technical Decisions')
    for (const d of decisions) {
      sections.push(`- **${d.context}** — ${d.question}: ${d.answer}`)
    }
  }

  // Blocked items
  const blocked = project.nodes.filter((n) => n.status === 'blocked')
  if (blocked.length > 0) {
    sections.push('\n## Blocked Items')
    for (const b of blocked) {
      sections.push(`- ${b.title} (${b.type})${b.description ? `: ${b.description}` : ''}`)
    }
  }

  return sections.join('\n')
}

/**
 * Generate plan.md in Spec Kit-compatible format.
 */
export function generatePlanMD(project: Project): string {
  const sections: string[] = []

  sections.push(`# Plan: ${project.title}`)
  sections.push(`\n> Generated by VisionPath on ${new Date().toISOString().split('T')[0]}`)

  const goals = project.nodes.filter((n) => n.type === 'goal')
  for (const goal of goals) {
    sections.push(`\n## ${goal.title}`)
    if (goal.description) sections.push(`\n${goal.description}`)

    const subgoals = project.nodes.filter((n) => n.parentId === goal.id)
    for (const sg of subgoals) {
      sections.push(`\n### ${sg.title}`)
      if (sg.description) sections.push(`\n${sg.description}`)

      const features = project.nodes.filter((n) => n.parentId === sg.id)
      for (const f of features) {
        sections.push(`\n#### ${f.title}`)
        if (f.description) sections.push(`\n${f.description}`)

        const decisions = getNodeDecisions(f)
        if (decisions.length > 0) {
          sections.push('\n**Decisions:**')
          for (const d of decisions) {
            sections.push(`- ${d.question}: ${d.answer}`)
          }
        }
      }
    }
  }

  return sections.join('\n')
}

/**
 * Generate tasks.md as a flat checklist grouped by feature.
 */
export function generateTasksMD(project: Project): string {
  const sections: string[] = []

  sections.push(`# Tasks: ${project.title}`)
  sections.push(`\n> Generated by VisionPath on ${new Date().toISOString().split('T')[0]}`)

  const total = project.nodes.filter((n) => n.type === 'task').length
  const completed = project.nodes.filter((n) => n.type === 'task' && n.status === 'completed').length
  sections.push(`\n**Progress:** ${completed}/${total} tasks complete`)

  const goals = project.nodes.filter((n) => n.type === 'goal')
  for (const goal of goals) {
    sections.push(`\n## ${goal.title}`)

    const descendants = getOrderedDescendants(goal.id, project.nodes)
    let currentFeature = ''
    for (const node of descendants) {
      if (node.type === 'feature' || node.type === 'subgoal') {
        currentFeature = node.title
        sections.push(`\n### ${node.title}`)
      } else if (node.type === 'task') {
        const cb = node.status === 'completed' ? '[x]' : '[ ]'
        const blocked = node.status === 'blocked' ? ' ⛔ BLOCKED' : ''
        sections.push(`- ${cb} ${node.title}${blocked}`)
      }
    }
  }

  return sections.join('\n')
}

// --- Helpers ---

function collectAllDecisions(nodes: PlanNode[]): { context: string; question: string; answer: string }[] {
  const results: { context: string; question: string; answer: string }[] = []
  for (const node of nodes) {
    const decisions = getNodeDecisions(node)
    for (const d of decisions) {
      results.push({ context: node.title, ...d })
    }
  }
  return results
}

function getNodeDecisions(node: PlanNode): { question: string; answer: string }[] {
  return (node.questions || [])
    .filter((q) => (q.answer ?? '').trim() !== '')
    .map((q) => ({ question: q.question, answer: q.answer }))
}

function collectConstraints(project: Project): string[] {
  const constraints: string[] = []
  for (const node of project.nodes) {
    if (node.prds) {
      for (const prd of node.prds) {
        // Extract lines that look like constraints
        const lines = prd.content.split('\n')
        for (const line of lines) {
          if (line.match(/^[-*]\s/) && line.toLowerCase().includes('must')) {
            constraints.push(line.replace(/^[-*]\s+/, '').trim())
          }
        }
      }
    }
  }
  return constraints.slice(0, 20) // Cap at 20 constraints
}

function getOrderedDescendants(nodeId: string, nodes: PlanNode[]): PlanNode[] {
  const result: PlanNode[] = []
  function collect(parentId: string) {
    const children = nodes.filter((n) => n.parentId === parentId)
    for (const child of children) {
      result.push(child)
      collect(child.id)
    }
  }
  collect(nodeId)
  return result
}
